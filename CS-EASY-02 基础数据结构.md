# CS-EASY-02 基础数据结构

### Q1.什么是随机存取？这个性质属于哪种线性表的特征？

随机存取是指，数据在被读取或写入时，所需时间与该数据所在物理选址无关。

这种随机存储体现在数据结构上时，意味着该种容器支持以**下标访问**元素，且这一操作复杂度为 $O(1)$ ，即，若要存取或访问某个元素，无需遍历其容器中编号更前的元素，而是可以**直接**访问，与其存储位置**无关**。



这种性质属于**顺序表（数组）**的特征。





### Q2.什么是指针？如何在C语言中定义指针变量？指针变量的大小是固定的吗？

指针是一种存储了某个变量的**内存地址**的变量，其存储的值是地址。

C语言中定义指针的方法如下：

```c
int *ptr
float *ptr
char *ptr
//都是以类型加上 * 再加变量名的形式
```

指针变量的大小一般是**固定的**，因为其存储的值是**地址**，计算机系统中的地址由一个无符号整数表示，而其大小取决于**系统**，如果是32位系统，通常是4字节，而64位系统则是8字节。





### Q3.你能为不同的数据结构设想出适用的具体情况吗？

1. 从不同数据结构的性质上：

- **数组**

  应用范围非常广，基于其访问数据迅速，操作简单，在大部分需要存储数据集合的问题中，如果没有特殊的容器性质要求，一般都会使用数组。并且数组也是**构建其他数据结构**，存储**图**等数学对象的基础。

- **链表**

  当需要维护序列元素之间的**相对位置**，比如在元素之中**插入或删除**元素时比较常用。基于其特性，只需改变插入位置相邻元素**头尾指针**的指向即可，不需要对剩余元素进行额外操作。

- **栈**

  常用于处理**后进先出**的数据操作。

- **队列**

  与栈相对，处理**先进先出**的数据操作。



2. 算法

丰富多样的**数据结构**是研究各种**算法问题**的基础。



比如图论，图论是算法问题中最经典，最丰富的领域~~（我猜的）~~

- 在最基本的存图问题上，当然少不了各种数据结构，比如最常用**邻接表存图**就要用到**数组**。
- 还有各种专门算法，比如**拓扑排序**少不了**栈**结构，**最小生成树**的优化要用到**优先队列**或者**并查集**，**最短路径问题**需要**优先队列**等等。



除此之外，在复杂的**区间问题**上，也有线段树，平衡树，可持久化数据结构的各种应用。





### Q4.如何使用C语言保存一张图的信息？

最常用（？）的方法是**邻接表存图**，代码如下：

```c
struct line{int to,w,pre;};
line b[500005];
int head[100005],t;
void ad(int x,int y,int z)//传入的参数分别是边的起点终点和边权
{
	t++;
	b[t].to=y;
	b[t].w=z;
	b[t].pre=head[x];//这里的前驱赋值为以x为起点的上一条边的编号
	head[x]=t;
}
```



具体来说，使用一个结构体来定义一个边的类型，其三个成员分别表示**边指向的节点**、**边权**和**前驱（相同起点的上一条边的序号）**。

并且使用一个**全局变量**（代码中是 `t` ）来记录所有边的编号，`head[x]` 表示以 `x` 为起点的边的序号。



当我们研究的问题是**无权图**时，也可以采取**不使用结构体**的这种方式：

```c
int head[N],pre[M],ver[M],t;
void add(int x,int y){
    ver[++t]=y;pre[t]=head[x];head[x]=t;
}
```





## 数据结构的应用

### Part 1

一点小建议：个人觉得设计样例时应该加上**第一行输入一个数**，表示接下来输入的**操作的数量**，以便于对程序进行多组样例的测试。

具体链表实现见 **Part1 代码**。



### Part 2&3

解密过程：

- 先模拟约瑟夫环问题写一个用于**报数**的函数，然后扫描链表到 $3$ 出现的位置，从此位置开始进行报数和删除元素，最后将输出结果保存在 `Josephus.out` 文件中。
- 再手写一个栈，把密文串和 `Josephus.out` 文件整合在 `part3.in` 文件中，读入，并根据题目要求操作栈进行解密，结果输出在 `part3.out` 文件中。
- 详细的具体**解密过程**和**代码逻辑**见 **Part2 和Part3 的代码**，同时一并附上 `Josephus.out` `part3.in` `part3.out` 文件。



### 解密结果

<center>glimmerinheartnofear4dark</center>

<center><b>心有微光，不惧黑暗</b></center>
